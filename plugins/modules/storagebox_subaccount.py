#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2025 Victor LEFEBVRE <dev@vic1707.xyz>
# GNU General Public License v3.0+ (see LICENSES/GPL-3.0-or-later.txt or https://www.gnu.org/licenses/gpl-3.0.txt)
# SPDX-License-Identifier: GPL-3.0-or-later

from __future__ import absolute_import, division, print_function

__metaclass__ = type


DOCUMENTATION = r"""
module: storagebox_subaccount
short_description: Create, update, or delete the subaccounts for a storage box
version_added: 2.4.0
author:
  - Victor LEFEBVRE (@vic1707)
description:
  - Create, update, or delete the subaccounts for a storage box.
extends_documentation_fragment:
  - community.hrobot.robot
  - community.hrobot.attributes
  - community.hrobot.attributes.actiongroup_robot

attributes:
  check_mode:
    support: full
  diff_mode:
    support: none
  idempotent:
    support: full

options:
  storagebox_id:
    description:
      - The ID of the storage box to query.
    type: int
    required: true
  subaccounts:
    description:
      - The subaccounts configurations.
    type: list
    elements: dict
    required: true
    suboptions:
      state:
        description:
          - Desired state of this subaccount.
        choices: [present, absent]
        default: present
        type: str

      username:
        description:
          - Username of the subaccount.
          - Required for updating or deleting a subaccount (C(state=absent) or update with C(state=present)).
          - Omit to create a new subaccount (C(state=present)).
        type: str
        required: false

      password:
        description:
          - Password to use or change.
          - If omitted and state is C(present) or C(password), a random password is generated by hrobot.
        type: str
        required: false

      homedirectory:
        description:
          - Home directory of the subaccount.
          - Required when creating or updating a subaccount (C(state=present)).
        type: str
        required: false

      samba:
        description:
          - Enable or disable Samba.
        type: bool
        default: false
        required: false

      ssh:
        description:
          - Enable or disable SSH access.
        type: bool
        default: false
        required: false

      external_reachability:
        description:
          - Enable or disable external reachability.
        type: bool
        default: false
        required: false

      webdav:
        description:
          - Enable or disable WebDAV.
        type: bool
        default: false
        required: false

      readonly:
        description:
          - Enable or disable read-only mode.
        type: bool
        default: false
        required: false

      comment:
        description:
          - A custom comment for the subaccount.
        type: str
        default: ""
        required: false

notes:
  - The module is fully idempotent and supports check mode.
  - Passwords cannot be compared or diffed, so changes to passwords will always appear as changed in check mode and will not show diffs.
  - When passwords are autogenerated by the API (by omitting the C(password) field), the resulting password is returned.
"""

EXAMPLES = r"""
---
- name: Create a new subaccount with random password
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccounts:
      - homedirectory: "/backups/project1"
        samba: true
        ssh: true
        webdav: false
        comment: "Backup for Project 1"

- name: Create multiple subaccounts with custom passwords
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccounts:
      - username: "backup1"
        password: "s3cretPass123"
        homedirectory: "/data/backup1"
        readonly: false
        samba: true
        ssh: false
      - username: "backup2"
        password: "an0therPass!"
        homedirectory: "/data/backup2"
        samba: false
        ssh: true
        comment: "Team B storage"

- name: Update an existing subaccount
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccounts:
      - state: present
        username: "backup1"
        homedirectory: "/data/backup1-updated"
        readonly: true
        comment: "Updated path and readonly mode"

- name: Delete a subaccount
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccounts:
      - state: absent
        username: "backup2"

- name: Change password for a subaccount
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccounts:
      - state: present # TODO: state: password?
        username: "backup1"
        password: "n3wSecur3Pass"
"""

RETURN = r"""
deleted_subaccounts:
  description: List of usernames of subaccounts that were deleted.
  type: list
  elements: str
  returned: always
  sample: ["backup1", "olduser"]

untouched_subaccounts:
  description: List of usernames of subaccounts that required no changes.
  type: list
  elements: str
  returned: always
  sample: ["team_a", "shared_storage"]

updated_subaccounts:
  description: List of usernames of subaccounts whose configuration was updated (excluding password changes).
  type: list
  elements: str
  returned: always
  sample: ["backup1", "team_b"]

password_updated_subaccounts:
  description: List of usernames of subaccounts whose password was updated.
  type: list
  elements: str
  returned: always
  sample: ["backup2"]

created_subaccounts:
  description: List of created subaccounts. Each item includes the full response from the API or a string if check mode was used.
  type: list
  elements: raw
  returned: always
  sample:
    - username: "newuser"
      password: "randomlyGeneratedPass123"
      homedirectory: "/data/newuser"
    - "<new with homedirectory /backups/newproject>"
"""

from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.six.moves.urllib.parse import urlencode

from ansible_collections.community.hrobot.plugins.module_utils.robot import (
    BASE_URL,
    ROBOT_DEFAULT_ARGUMENT_SPEC,
    fetch_url_json,
)


def encode_data(data):
    """Converts booleans to lowercase strings and filters out None values."""
    return urlencode(
        {
            key: str(value).lower() if isinstance(value, bool) else value
            for key, value in data.items()
            if value is not None
        }
    )


def create_subaccount(module, storagebox_id, subaccount):
    url = "{0}/storagebox/{1}/subaccount".format(BASE_URL, storagebox_id)
    res, error = fetch_url_json(
        module,
        url,
        method="POST",
        data=encode_data(subaccount),
        headers={"Content-type": "application/x-www-form-urlencoded"},
        accept_errors=[
            "STORAGEBOX_NOT_FOUND",
            "STORAGEBOX_SUBACCOUNT_LIMIT_EXCEEDED",
            "STORAGEBOX_INVALID_PASSWORD",
        ],
        timeout=30000,  # this endpoint is stupidly slow
    )
    if not error:
        return res

    if error == "STORAGEBOX_INVALID_PASSWORD":
        module.fail_json(
            msg="Subaccount with username '{0}' and homedirectory '{1}' has an invalid password (says Hetzner)".format(
                subaccount.get("username", "<missing>"),
                subaccount.get("homedirectory", "<missing>"),
            )
        )
    if error == "STORAGEBOX_SUBACCOUNT_LIMIT_EXCEEDED":
        module.fail_json(msg="Subaccount limit exceeded")

    module.fail_json(
        msg="Unknown error: {0} for username '{1}' and homedirectory '{2}'".format(
            error,
            subaccount.get("username", "<missing>"),
            subaccount.get("homedirectory", "<missing>"),
        )
    )  # pragma: no cover


class Subaccount:
    def __init__(self, storagebox_id, username=None, homedirectory="",
                 samba=False, ssh=False, external_reachability=False, webdav=False, readonly=False,
                 comment="", **dummy):
        self.storagebox_id = storagebox_id
        self.username = username
        self.homedirectory = homedirectory
        self.samba = samba
        self.ssh = ssh
        self.external_reachability = external_reachability
        self.webdav = webdav
        self.readonly = readonly
        self.comment = comment

    def delete(self, module):
        dummy, error = fetch_url_json(
            module,
            self.mgmt_url(),
            method="DELETE",
            allow_empty_result=True,
            headers={"Content-type": "application/x-www-form-urlencoded"},
            accept_errors=[
                "STORAGEBOX_NOT_FOUND",
                "STORAGEBOX_SUBACCOUNT_NOT_FOUND",
            ],
        )
        # function is only called when storagebox and subaccount were already verified
        if error is not None:  # pragma: no cover
            raise AssertionError('Unhandled error happened during deletion of {0}'.format(self.username))  # pragma: no cover

    def update(self, module):
        res, error = fetch_url_json(
            module,
            self.mgmt_url(),
            method="PUT",
            data=encode_data(self.__dict__),
            headers={"Content-type": "application/x-www-form-urlencoded"},
            accept_errors=[
                "STORAGEBOX_NOT_FOUND",
                # TODO: no error on unknown username?
            ],
            allow_empty_result=True,
            timeout=30000,  # this endpoint is stupidly slow
        )
        # function is only called when storagebox and subaccount were already verified
        if error is not None:  # pragma: no cover
            raise AssertionError('Unhandled error happened during update of {0}'.format(self.username))  # pragma: no cover
        return res

    def update_password(self, module, password):
        dummy, error = fetch_url_json(
            module,
            "{0}/password".format(self.mgmt_url()),
            method="POST",
            data=encode_data({"password": password}),
            headers={"Content-type": "application/x-www-form-urlencoded"},
            accept_errors=[
                "STORAGEBOX_NOT_FOUND",
                "STORAGEBOX_SUBACCOUNT_NOT_FOUND",
                "STORAGEBOX_INVALID_PASSWORD",
            ],
            timeout=30000,  # this endpoint is stupidly slow
        )
        if error == "STORAGEBOX_INVALID_PASSWORD":
            module.fail_json(
                msg="Subaccount with username '{0}' and homedirectory '{1}' has an invalid password (says Hetzner)".format(
                    self.username or "<missing>", self.homedirectory or "<missing>"
                )
            )
        # function is only called when storagebox and subaccount were already verified
        if error is not None:  # pragma: no cover
            raise AssertionError('Unhandled error happened during password update of {0}'.format(self.username))  # pragma: no cover

    def mgmt_url(self):
        return "{0}/storagebox/{1}/subaccount/{2}".format(
            BASE_URL, self.storagebox_id, self.username
        )

    def __eq__(self, other):
        if not isinstance(other, Subaccount):
            return False
        return self.__dict__ == other.__dict__


def get_subaccounts(module, storagebox_id):
    url = "{0}/storagebox/{1}/subaccount".format(BASE_URL, storagebox_id)
    result, error = fetch_url_json(module, url, accept_errors=["STORAGEBOX_NOT_FOUND"])
    if error:
        module.fail_json(
            msg="Storagebox with ID {0} does not exist".format(storagebox_id)
        )
    return [Subaccount(storagebox_id, **item["subaccount"]) for item in result]


def main():
    argument_spec = dict(
        storagebox_id=dict(type="int", required=True),
        subaccounts=dict(
            type="list",
            elements="dict",
            required=True,
            options=dict(
                state=dict(type="str", default="present", choices=["present", "absent"]),
                username=dict(type="str"),
                password=dict(type="str", no_log=True),
                homedirectory=dict(type="str"),
                samba=dict(type="bool", default=False),
                ssh=dict(type="bool", default=False),
                external_reachability=dict(type="bool", default=False),
                webdav=dict(type="bool", default=False),
                readonly=dict(type="bool", default=False),
                comment=dict(type="str", default=""),
            ),
        ),
    )
    argument_spec.update(ROBOT_DEFAULT_ARGUMENT_SPEC)
    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True,
    )

    check_mode = module.check_mode
    storagebox_id = module.params["storagebox_id"]

    existing_subaccounts = get_subaccounts(module, storagebox_id)

    deleted_subaccounts = []
    untouched_subaccounts = []
    updated_subaccounts = []
    password_updated_subaccounts = []
    created_subaccounts = []
    for subaccount in module.params["subaccounts"]:
        username = subaccount["username"]
        existing = next(
            (sa for sa in existing_subaccounts if sa.username == username), None
        )

        if subaccount["state"] == "absent":
            if not username:
                module.fail_json(msg="username is required when state is 'absent'")

            if existing:
                not check_mode and existing.delete(module)
                deleted_subaccounts.append(username)
                existing_subaccounts.remove(existing)
            else:
                untouched_subaccounts.append(username)

        elif subaccount["state"] == "present" and existing:
            if subaccount["password"]:
                not check_mode and existing.update_password(
                    module, subaccount["password"]
                )
                password_updated_subaccounts.append(username)

            wanted_subaccount = Subaccount(storagebox_id, **subaccount)
            if wanted_subaccount == existing:
                untouched_subaccounts.append(username)
                continue

            not check_mode and wanted_subaccount.update(module)
            updated_subaccounts.append(username)
        else:
            if not subaccount.get("homedirectory"):
                module.fail_json(
                    msg="homedirectory is required when creating a new subaccount"
                )
            res = None
            if not check_mode:
                res = create_subaccount(module, storagebox_id, subaccount)
            created_subaccounts.append(
                res
                or "<new with homedirectory {0}>".format(subaccount["homedirectory"])
            )

    module.exit_json(
        changed=any(
            len(changed) != 0
            for changed in [
                deleted_subaccounts,
                updated_subaccounts,
                password_updated_subaccounts,
                created_subaccounts,
            ]
        ),
        deleted_subaccounts=deleted_subaccounts,
        untouched_subaccounts=untouched_subaccounts,
        updated_subaccounts=updated_subaccounts,
        password_updated_subaccounts=password_updated_subaccounts,
        created_subaccounts=created_subaccounts,
    )


if __name__ == "__main__":  # pragma: no cover
    main()  # pragma: no cover
