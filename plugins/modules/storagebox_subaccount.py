#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2025 Victor LEFEBVRE <dev@vic1707.xyz>
# GNU General Public License v3.0+ (see LICENSES/GPL-3.0-or-later.txt or https://www.gnu.org/licenses/gpl-3.0.txt)
# SPDX-License-Identifier: GPL-3.0-or-later

from __future__ import absolute_import, division, print_function

__metaclass__ = type


DOCUMENTATION = r"""
module: storagebox_subaccount
short_description: Create, update, or delete a subaccount for a storage box
version_added: 2.4.0
author:
  - Victor LEFEBVRE (@vic1707)
description:
  - Create, update, or delete a subaccount for a storage box.
extends_documentation_fragment:
  - community.hrobot.robot
  - community.hrobot.attributes
  - community.hrobot.attributes.actiongroup_robot

attributes:
  check_mode:
    support: full
  diff_mode:
    support: none
  idempotent:
    support: full

options:
  storagebox_id:
    description:
      - The ID of the storage box to query.
    type: int
    required: true
  password_mode:
    description:
      - Controls how password updates are handled.
      - If C(update-if-provided), the password is updated only if provided (default).
      - If C(ignore-if-exists), password is only used during creation.
      - If C(set-to-random), password is reset to a randomly generated one.
    type: str
    choices: [update-if-provided, ignore-if-exists, set-to-random]
    default: update-if-provided
    required: false
  subaccount:
    description:
      - The subaccount configuration.
    type: dict
    required: true
    suboptions:
      state:
        description:
          - Desired state of this subaccount.
        choices: [present, absent]
        default: present
        type: str

      username:
        description:
          - Username of the subaccount.
          - Required for updating or deleting a subaccount (C(state=absent) or update with C(state=present)).
          - Omit to create a new subaccount (C(state=present)).
        type: str
        required: false

      password:
        description:
          - Password to use or change.
          - If omitted and state is C(present), a random password is generated by hrobot.
        type: str
        required: false

      homedirectory:
        description:
          - Home directory of the subaccount.
          - Required when creating or updating a subaccount (C(state=present)).
        type: str
        required: false

      samba:
        description:
          - Enable or disable Samba.
        type: bool
        default: false
        required: false

      ssh:
        description:
          - Enable or disable SSH access.
        type: bool
        default: false
        required: false

      external_reachability:
        description:
          - Enable or disable external reachability.
        type: bool
        default: false
        required: false

      webdav:
        description:
          - Enable or disable WebDAV.
        type: bool
        default: false
        required: false

      readonly:
        description:
          - Enable or disable read-only mode.
        type: bool
        default: false
        required: false

      comment:
        description:
          - A custom comment for the subaccount.
        type: str
        default: ""
        required: false
      idempotence:
        description:
          - Select which attribute to use to check subaccount existence.
          - C(username) or C(comment).
        type: str
        choices: [username, comment]
        default: username
        required: false

notes:
  - The module is fully idempotent and supports check mode.
  - Passwords cannot be compared or diffed, so changes to passwords will always appear as changed in check mode and will not show diffs.
  - When passwords are autogenerated by the API (by omitting the C(password) field), the resulting password is returned.
"""

EXAMPLES = r"""
---
- name: Create a new subaccount with random password
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccount:
      homedirectory: "/backups/project1"
      samba: true
      ssh: true
      webdav: false
      comment: "Backup for Project 1"

- name: Create a subaccount with custom password
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccount:
      username: "backup1"
      password: "s3cretPass123"
      homedirectory: "/data/backup1"
      readonly: false
      samba: true
      ssh: false

- name: Update an existing subaccount
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccount:
      state: present
      username: "backup1"
      homedirectory: "/data/backup1-updated"
      readonly: true
      comment: "Updated path and readonly mode"

- name: Delete a subaccount
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccount:
      state: absent
      username: "backup1"

- name: Change password for a subaccount
  community.hrobot.storagebox_subaccount:
    storagebox_id: 123456
    subaccount:
      state: present
      username: "backup1"
      password: "n3wSecur3Pass"
"""

RETURN = r"""
created:
  description: Whether a new subaccount was created.
  type: bool
  returned: always

deleted:
  description: Whether the subaccount was deleted.
  type: bool
  returned: always

updated:
  description: Whether the subaccount's configuration was updated (excluding password changes).
  type: bool
  returned: always

password_updated:
  description: Whether the subaccount's password was updated.
  type: bool
  returned: always

created_subaccount:
  description: The created subaccount object returned from the API.
  type: raw
  returned: when created is true
"""

from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils.six.moves.urllib.parse import urlencode

from ansible_collections.community.hrobot.plugins.module_utils.robot import (
    BASE_URL,
    ROBOT_DEFAULT_ARGUMENT_SPEC,
    fetch_url_json,
)


def encode_data(data):
    """Converts booleans to lowercase strings and filters out None values."""
    return urlencode(
        {
            key: str(value).lower() if isinstance(value, bool) else value
            for key, value in data.items()
            if value is not None
        }
    )


def create_subaccount(module, storagebox_id, subaccount):
    url = "{0}/storagebox/{1}/subaccount".format(BASE_URL, storagebox_id)
    res, error = fetch_url_json(
        module,
        url,
        method="POST",
        data=encode_data(subaccount),
        headers={"Content-type": "application/x-www-form-urlencoded"},
        accept_errors=[
            "STORAGEBOX_NOT_FOUND",
            "STORAGEBOX_SUBACCOUNT_LIMIT_EXCEEDED",
            "STORAGEBOX_INVALID_PASSWORD",
        ],
        timeout=30000,  # this endpoint is stupidly slow
    )
    if not error:
        return res

    if error == "STORAGEBOX_INVALID_PASSWORD":
        module.fail_json(
            msg="Creation of user with homedirectory '{0}' has an invalid password (says Hetzner)".format(
                subaccount.get("homedirectory", "<missing>"),
            )
        )
    if error == "STORAGEBOX_SUBACCOUNT_LIMIT_EXCEEDED":
        module.fail_json(msg="Subaccount limit exceeded")

    module.fail_json(
        msg="Unknown error: {0} for username '{1}' and homedirectory '{2}'".format(
            error,
            subaccount.get("username", "<missing>"),
            subaccount.get("homedirectory", "<missing>"),
        )
    )  # pragma: no cover


class Subaccount:
    def __init__(self, storagebox_id, username=None, homedirectory="",
                 samba=False, ssh=False, external_reachability=False, webdav=False, readonly=False,
                 comment="", **dummy):
        self.storagebox_id = storagebox_id
        self.username = username
        self.homedirectory = homedirectory
        self.samba = samba
        self.ssh = ssh
        self.external_reachability = external_reachability
        self.webdav = webdav
        self.readonly = readonly
        self.comment = comment

    def delete(self, module):
        dummy, error = fetch_url_json(
            module,
            self.mgmt_url(),
            method="DELETE",
            allow_empty_result=True,
            headers={"Content-type": "application/x-www-form-urlencoded"},
            accept_errors=[
                "STORAGEBOX_NOT_FOUND",
                "STORAGEBOX_SUBACCOUNT_NOT_FOUND",
            ],
        )
        # function is only called when storagebox and subaccount were already verified
        if error is not None:  # pragma: no cover
            raise AssertionError('Unhandled error happened during deletion of {0}'.format(self.username))  # pragma: no cover

    def update(self, module):
        res, error = fetch_url_json(
            module,
            self.mgmt_url(),
            method="PUT",
            data=encode_data(self.__dict__),
            headers={"Content-type": "application/x-www-form-urlencoded"},
            accept_errors=[
                "STORAGEBOX_NOT_FOUND",
                # TODO: no error on unknown username?
            ],
            allow_empty_result=True,
            timeout=30000,  # this endpoint is stupidly slow
        )
        # function is only called when storagebox and subaccount were already verified
        if error is not None:  # pragma: no cover
            raise AssertionError('Unhandled error happened during update of {0}'.format(self.username))  # pragma: no cover
        return res

    def update_password(self, module, password):
        dummy, error = fetch_url_json(
            module,
            "{0}/password".format(self.mgmt_url()),
            method="POST",
            data=encode_data({"password": password}),
            headers={"Content-type": "application/x-www-form-urlencoded"},
            accept_errors=[
                "STORAGEBOX_NOT_FOUND",
                "STORAGEBOX_SUBACCOUNT_NOT_FOUND",
                "STORAGEBOX_INVALID_PASSWORD",
            ],
            timeout=30000,  # this endpoint is stupidly slow
        )
        if error == "STORAGEBOX_INVALID_PASSWORD":
            module.fail_json(
                msg="Subaccount with username '{0}' and homedirectory '{1}' has an invalid password (says Hetzner)".format(
                    self.username or "<missing>", self.homedirectory or "<missing>"
                )
            )
        # function is only called when storagebox and subaccount were already verified
        if error is not None:  # pragma: no cover
            raise AssertionError('Unhandled error happened during password update of {0}'.format(self.username))  # pragma: no cover

    def mgmt_url(self):
        return "{0}/storagebox/{1}/subaccount/{2}".format(
            BASE_URL, self.storagebox_id, self.username
        )

    def __eq__(self, other):
        if not isinstance(other, self.__class__):  # pragma: no cover
            return False  # pragma: no cover
        return self.__dict__ == other.__dict__

    # Python 2, I hate you
    def __ne__(self, other):
        return not self.__eq__(other)


def get_subaccounts(module, storagebox_id):
    url = "{0}/storagebox/{1}/subaccount".format(BASE_URL, storagebox_id)
    result, error = fetch_url_json(module, url, accept_errors=["STORAGEBOX_NOT_FOUND"])
    if error:
        module.fail_json(
            msg="Storagebox with ID {0} does not exist".format(storagebox_id)
        )
    return [Subaccount(storagebox_id, **item["subaccount"]) for item in result]


def main():
    argument_spec = dict(
        storagebox_id=dict(type="int", required=True),
        subaccount=dict(
            type="dict",
            required=True,
            options=dict(
                state=dict(type="str", default="present", choices=["present", "absent"]),
                username=dict(type="str"),
                password=dict(type="str", no_log=True),
                homedirectory=dict(type="str"),
                samba=dict(type="bool", default=False),
                ssh=dict(type="bool", default=False),
                external_reachability=dict(type="bool", default=False),
                webdav=dict(type="bool", default=False),
                readonly=dict(type="bool", default=False),
                comment=dict(type="str", default=""),
                idempotence=dict(type="str", choices=["username", "comment"], default="username"),
            ),
        ),
        password_mode=dict(
            type="str",
            choices=["update-if-provided", "ignore-if-exists", "set-to-random"],
            default="update-if-provided",
        ),
    )
    argument_spec.update(ROBOT_DEFAULT_ARGUMENT_SPEC)
    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True,
    )

    check_mode = module.check_mode
    storagebox_id = module.params["storagebox_id"]
    subaccount = module.params["subaccount"]
    password_mode = module.params['password_mode']

    account_identifier = subaccount[subaccount["idempotence"]]

    existing_subaccounts = get_subaccounts(module, storagebox_id)
    existing = next(
        (
            sa for sa in existing_subaccounts
            if getattr(sa, subaccount["idempotence"], None) == account_identifier
        ),
        None,
    )

    created = deleted = updated = password_updated = False
    created_subaccount = None

    if subaccount["state"] == "absent":
        if existing:
            if not check_mode:
                existing.delete(module)
            deleted = True
    elif subaccount["state"] == "present" and existing:
        # Set the found username in case user used comment as idempotence
        subaccount['username'] = existing.__dict__['username']

        if password_mode == "set-to-random":
            subaccount["password"] = None
        if password_mode == "set-to-random" \
           or (password_mode == "update-if-provided" and subaccount["password"]):
            if not check_mode:
                existing.update_password(module, subaccount["password"])
            password_updated = True

        wanted_subaccount = Subaccount(storagebox_id, **subaccount)
        if wanted_subaccount != existing:
            if not check_mode:
                wanted_subaccount.update(module)
            updated = True
    else:  # state 'present' without pre-existing account
        if not subaccount["homedirectory"]:
            module.fail_json(
                msg="homedirectory is required when creating a new subaccount"
            )
        if password_mode == "set-to-random":
            subaccount["password"] = None

        if not check_mode:
            created_subaccount = create_subaccount(module, storagebox_id, subaccount)
        else:
            created_subaccount = "<new with homedirectory {0}>".format(
                subaccount["homedirectory"]
            )
        created = True

    module.exit_json(
        changed=any([created, deleted, updated, password_updated]),
        created=created,
        deleted=deleted,
        updated=updated,
        password_updated=password_updated,
        created_subaccount=created_subaccount if created else None,
    )


if __name__ == "__main__":  # pragma: no cover
    main()  # pragma: no cover
